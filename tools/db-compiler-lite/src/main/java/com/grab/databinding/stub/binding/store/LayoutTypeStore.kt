/*
 * Copyright 2021 Grabtaxi Holdings PTE LTE (GRAB)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.grab.databinding.stub.binding.store

import com.grab.databinding.stub.common.CLASS_INFO
import com.grab.databinding.stub.common.LAYOUT_FILES
import com.grab.databinding.stub.common.PACKAGE_NAME
import com.grab.databinding.stub.util.toLayoutBindingName
import com.squareup.javapoet.ClassName
import com.squareup.javapoet.TypeName
import dagger.Binds
import dagger.Module
import java.io.File
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import java.nio.file.attribute.BasicFileAttributes
import java.util.function.BiPredicate
import java.util.zip.ZipFile
import javax.inject.Inject
import javax.inject.Named
import javax.inject.Singleton
import kotlin.LazyThreadSafetyMode.NONE
import kotlin.streams.asSequence

/**
 * Store that is able to provide [TypeName] when given a layout name represented as simple string
 * i.e without `@layout/`.
 */
interface LayoutTypeStore {
    /**
     * For a given [layoutName], return the fully qualified class name as [TypeName] instance that
     * would be generated by databinding compiler.
     */
    operator fun get(layoutName: String): TypeName?
}

const val LOCAL = "local"
const val DEPS = "deps"

@Module(includes = [BindingClassJsonParserModule::class])
interface LayoutStoreModule {
    @Named(LOCAL)
    @Binds
    fun LocalModuleLayoutTypeStore.localStore(): LayoutTypeStore

    @Named(DEPS)
    @Binds
    fun DependenciesLayoutTypeStore.depsStore(): LayoutTypeStore
}

/**
 * [LayoutTypeStore] implementation that looks for generated [TypeName] for a layout in current module's
 * layout source file.
 *
 * This class infers the generated class name from the layout name itself. For example, for
 * `simple_layout`, the generated class name will be `<package-name>.databinding.SimpleLayoutBinding`
 */
@Singleton
class LocalModuleLayoutTypeStore
@Inject
constructor(
    @Named(PACKAGE_NAME) currentTargetPackageName: String,
    @Named(LAYOUT_FILES) layoutFiles: List<File>
) : LayoutTypeStore {

    /**
     * Caches all the layout name and their generated class name.
     */
    private val layoutTypeMap: Map</* layout name */String, TypeName> by lazy(NONE) {
        layoutFiles
            .asSequence()
            .map { file ->
                val key = file.name.split(".xml").first()
                val value = ClassName.get(
                    "$currentTargetPackageName.databinding",
                    key.toLayoutBindingName()
                )
                key to value
            }.toMap()
    }

    override fun get(layoutName: String) = layoutTypeMap[layoutName]
}

/**
 * [LayoutTypeStore] implementation that searches layout type for the given layout in the
 * given dependencies' [classInfoZip] file.
 *
 * The implementation lazily parses the files on demand and utilizes caching to avoid doing
 * duplicating work.
 *
 * @param classInfoZip The merged zip provided from Bazel containing binding classes json files
 *                     of immediate dependencies
 * @param bindingClassJsonParser [BindingClassJsonParser] implementation that will be used to parse
 *                     contents of each binding class json file.
 */
@Singleton
class DependenciesLayoutTypeStore
@Inject
constructor(
    @Named(CLASS_INFO) private val classInfoZip: File,
    private val bindingClassJsonParser: BindingClassJsonParser
) : LayoutTypeStore {

    /**
     * The directory where contents of [classInfoZip] will be extracted to.
     */
    private val classInfoDir by lazy(NONE) {
        Paths.get("classInfos").let { Files.createDirectories(it) }
    }

    private val jsonFilePredicate = BiPredicate<Path, BasicFileAttributes> { path, attr ->
        attr.isRegularFile && path.toString().endsWith(".json")
    }

    /**
     * List of databinding binding class json files extracted on demand.
     */
    private val bindingClassJsons: List<File> by lazy(NONE) {
        ZipFile(classInfoZip).use { zip ->
            zip.entries().asSequence().forEach { entry ->
                zip.getInputStream(entry).use { input ->
                    val extractedFile = File(classInfoDir.toFile(), entry.name).apply {
                        parentFile?.mkdirs()
                    }
                    when {
                        entry.isDirectory -> extractedFile.mkdirs()
                        else -> extractedFile
                            .outputStream()
                            .use { output -> input.copyTo(output) }
                    }
                }
            }
        }
        Files
            .find(
                classInfoDir,
                Int.MAX_VALUE,
                jsonFilePredicate
            ).map(Path::toFile)
            .asSequence()
            // Iterate files starting from lowest size to avoid parsing large files eagerly
            .sortedBy { Files.size(it.toPath()) }
            .toList()
    }

    /**
     * Cache already served requests for layout typename
     */
    private val layoutTypeCache = mutableMapOf<String, String>()

    override fun get(layoutName: String): TypeName? {
        return if (layoutTypeCache.containsKey(layoutName)) {
            ClassName.bestGuess(layoutTypeCache[layoutName])
        } else {
            // Iterate over each file, parsing and checking for the given layout name. If found, exit
            // early and return the layout type.
            bindingClassJsons
                .forEach { jsonFile ->
                    // We iterate over file by file to avoid eagerly parsing all of them and can exit
                    // early on first occurrence. It is responsibility of `bindingClassJsonParser`
                    // to cache duplicate requests
                    val parsedContents: Map<String, String> = bindingClassJsonParser.parse(jsonFile)
                    if (parsedContents.containsKey(layoutName)) {
                        // Cache the request for future access
                        layoutTypeCache[layoutName] = parsedContents.getValue(layoutName)
                        return ClassName.bestGuess(layoutTypeCache[layoutName])
                    }
                }
            return null
        }
    }
}